<div id="background" class="inset absolute"></div>
<script>
  import Konva from "konva";

  /**
   * @see {@link file://./../styles/global.css} for color variables
   */
  const colors = [
    "rose",
    "sunglow",
    "papaya-whip",
    "dodger-blue",
    "pumpkin",
    "aquamarine",
  ].map((color) =>
    getComputedStyle(document.documentElement).getPropertyValue(
      `--color-${color}`
    )
  );

  function generateRandomPoints(index: number) {
    const length = 8;
    const radius = 50 * Math.pow(1.5, index + 1);
    const variance = radius * 0.3;

    return Array.from({ length }, (_, i) => {
      const angle = (i * 2 * Math.PI) / length;
      const r = radius + (Math.random() - 0.5) * variance;
      return [Math.cos(angle) * r, Math.sin(angle) * r];
    }).flat();
  }

  const stage = new Konva.Stage({
    container: "background",
    width: window.innerWidth,
    height: window.innerHeight,
  });

  const layer = new Konva.Layer();
  stage.add(layer);

  /**
   * Generate blobs
   * Add to layer in reverse order
   * Create tween for each blob in original order
   */
  const blobs = colors
    .map(
      (fill, i) =>
        new Konva.Line({
          points: generateRandomPoints(i),
          fill,
          stroke: "black",
          strokeWidth: 5,
          closed: true,
          tension: 0.3,
          offsetX: stage.width() / 2,
          offsetY: stage.height() / 2,
          x: stage.width() * 0.66,
          y: stage.height() * 0.33,
        })
    )
    .reverse()
    .map((node) => {
      layer.add(node);
      return node;
    })
    .reverse()
    .map((node) => ({
      node,
      tween: new Konva.Tween({
        node,
        duration: 2,
        easing: Konva.Easings.Linear,
      }),
    }));

  const period = 2000;
  let baseScale = 1;

  const anim = new Konva.Animation((frame) => {
    if (!frame) return;
    // Add slow expansion to the base scale (0.1 size increase per second)
    // baseScale += frame.timeDiff / 10000;
    // // Combine base expansion with the sine wave animation
    // const sineWave = Math.sin((frame.time * 2 * Math.PI) / period) * 0.1;
    // const scale = baseScale + sineWave;
    // blobs.forEach(({ node }) => node.scale({ x: scale, y: scale }));
  }, layer);

  anim.start();

  window.addEventListener("resize", () => {
    stage.width(window.innerWidth);
    stage.height(window.innerHeight);
    stage.draw();
  });

  window.addEventListener("mousemove", (e) => {
    stage.setPointersPositions(e);
    const pos = stage.getPointerPosition();
    if (!pos) return;

    blobs.forEach(({ node, tween }) => {
      tween.pause();
      tween.node.to({
        x: pos.x + node.offsetX(),
        y: pos.y + node.offsetY(),
      });
      tween.play();
    });
  });
</script>
