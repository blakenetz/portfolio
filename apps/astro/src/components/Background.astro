<div id="background" class="inset absolute"></div>
<script>
  import Konva from "konva";

  const cssStyleDeclaration = getComputedStyle(document.documentElement);

  /**
   * @see {@link file://./../styles/global.css} for color variables
   */
  const colors = [
    "rose",
    "sunglow",
    "dodger-blue",
    "papaya-whip",
    "pumpkin",
    "aquamarine",
  ];

  // Pythagorean theorem to get the diagonal distance of the screen
  const maxWidth = Math.sqrt(
    Math.pow(window.innerWidth, 2) + Math.pow(window.innerHeight, 2)
  );

  function generateRandomPoints(index: number) {
    const length = 8;
    const radius = 100 * Math.pow(1.5, index + 0.25);
    const variance = radius * 0.3;

    return Array.from({ length }, (_, i) => {
      const angle = (i * 2 * Math.PI) / length;
      const r = radius + (Math.random() - 0.5) * variance;
      return [Math.cos(angle) * r, Math.sin(angle) * r];
    }).flat();
  }

  function getGradientStops(color: string) {
    return Array.from({ length: 5 }).flatMap((_v, i) => [
      i ? 1 / i : 0,
      cssStyleDeclaration.getPropertyValue(`--color-${color}-${(i + 2) * 100}`),
    ]);
  }

  /** Create stage and initial layer */
  const stage = new Konva.Stage({
    container: "background",
    width: window.innerWidth,
    height: window.innerHeight,
  });
  const layer = new Konva.Layer();
  stage.add(layer);

  /**
   * Generate blob nodes until node radius is greater than maxWidth
   */
  const blobNodes: Konva.Line[] = [];
  let isFilled = false;
  while (!isFilled) {
    const index = blobNodes.length;
    const color = colors[index % colors.length];

    const x = stage.width() * 0.66;
    const y = stage.height() * 0.33;

    const node = new Konva.Line({
      points: generateRandomPoints(index),
      fillLinearGradientColorStops: getGradientStops(color),
      fillLinearGradientStartPoint: { x: x * -1, y: y * -1 },
      fillLinearGradientEndPoint: { x, y },
      stroke: "black",
      strokeWidth: 5,
      closed: true,
      tension: 0.3,
      x,
      y,
    });

    blobNodes.push(node);

    if (node.width() / 2 > maxWidth) {
      isFilled = true;
    }
  }

  /**
   * Add blobs to layer in reverse order
   * Rotate each blob to randomize gradient direction
   * Create tween for each blob in original order
   */
  const blobs = blobNodes
    .toReversed()
    .map((node) => {
      node.rotation(Math.random() * 360);
      layer.add(node);
      return node;
    })
    .reverse()
    .map((node, i) => ({
      node,
      tween: new Konva.Tween({ node }),
    }));

  /**
   * adjust stage dimensions when window resizes
   */
  window.addEventListener("resize", () => {
    stage.width(window.innerWidth);
    stage.height(window.innerHeight);
    stage.draw();
  });

  /**
   * move blobs to mouse position
   */
  window.addEventListener("mousemove", (e) => {
    stage.setPointersPositions(e);
    const pos = stage.getPointerPosition();
    if (!pos) return;

    blobs.forEach(({ tween }, i) => {
      tween.node.to({
        x: pos.x,
        y: pos.y,
        duration: 0.25 + i * 0.1,
        easing: Konva.Easings.Linear,
      });
    });
  });
</script>
