<section id="background" class="fixed inset-0 -z-10"></section>
<div
  id="noise"
  class="bg-size-200 pointer-events-none fixed -inset-[150%] h-[400%] w-[400%] bg-repeat opacity-15"
>
</div>
<main class="p-checkerboard-size fixed inset-0">
  <slot />
</main>

<style>
  #noise {
    animation: noise-anim 4s steps(8) infinite;
    background: url(/noise.png);
  }

  @keyframes noise-anim {
    0% {
      transform: translate(0, 0);
    }
    25% {
      transform: translate(-10%, 5%);
    }
    50% {
      transform: translate(5%, -10%);
    }
    75% {
      transform: translate(-5%, 10%);
    }
    100% {
      transform: translate(0, 0);
    }
  }
</style>

<script>
  import Konva from "konva";
  import { ANIMATE_COLORS_CLASSNAME } from "~/consts";

  const cssStyleDeclaration = getComputedStyle(document.documentElement);
  const abortController = new AbortController();

  const animatedTextEls = document.querySelectorAll(
    `.${ANIMATE_COLORS_CLASSNAME}`
  );

  /**
   * @see {@link file://./../styles/global.css} for color variables
   */
  const colors = ["rose", "dodger-blue", "sunglow", "pumpkin", "aquamarine"];

  // Pythagorean theorem to get the diagonal distance of the screen
  const maxWidth = Math.sqrt(
    Math.pow(window.innerWidth, 2) + Math.pow(window.innerHeight, 2)
  );

  function generateRandomPoints(index: number) {
    const length = 8;
    const radius = 100 * Math.pow(1.5, index + 0.25);
    const variance = radius * 0.3;

    return Array.from({ length }, (_, i) => {
      const angle = (i * 2 * Math.PI) / length;
      const r = radius + (Math.random() - 0.5) * variance;
      return [Math.cos(angle) * r, Math.sin(angle) * r];
    }).flat();
  }

  function getGradientStops(index: number) {
    const start = colors[index % colors.length]!;
    const end = colors[(index + 1) % colors.length]!;

    return [
      0,
      cssStyleDeclaration.getPropertyValue(`--color-${start}`),
      1,
      cssStyleDeclaration.getPropertyValue(`--color-${end}`),
    ];
  }

  /** Create stage and initial layer */
  const stage = new Konva.Stage({
    container: "background",
    width: window.innerWidth,
    height: window.innerHeight,
  });
  const layer = new Konva.Layer();
  stage.add(layer);

  /**
   * Generate blob nodes until node radius is greater than maxWidth
   */
  const blobNodes: Konva.Line[] = [];
  let isFilled = false;
  const stroke = cssStyleDeclaration.getPropertyValue(
    `--color-papaya-whip-100`
  );
  while (!isFilled) {
    const index = blobNodes.length;

    const x = stage.width() * 0.66;
    const y = stage.height() * 0.33;

    const node = new Konva.Line({
      points: generateRandomPoints(index),
      fillLinearGradientColorStops: [],
      fillLinearGradientStartPoint: { x: x * -1, y: y * -1 },
      fillLinearGradientEndPoint: { x, y },
      stroke,
      strokeWidth: 5,
      closed: true,
      tension: 0.3,
      x,
      y,
    });

    blobNodes.push(node);

    if (node.width() / 2 > maxWidth) {
      isFilled = true;
    }
  }

  /**
   * Add blobs to layer and group in reverse order
   * Rotate each blob to randomize gradient direction
   * Create tween for each blob in original order
   */
  const blobs = blobNodes
    .toReversed()
    .map((node) => {
      node.rotation(Math.random() * 360);
      layer.add(node);
      return node;
    })
    .reverse()
    .map((node) => ({ node, tween: new Konva.Tween({ node }) }));

  const animation = new Konva.Animation((frame) => {
    if (!frame) return;
    blobs.forEach(({ node }) => {
      node.skewX(Math.sin(frame.time / 1000) * 0.1);
    });
  });
  animation.start();

  /**
   * adjust stage dimensions when window resizes
   */
  window.addEventListener(
    "resize",
    () => {
      stage.width(window.innerWidth);
      stage.height(window.innerHeight);
      stage.draw();
    },
    { signal: abortController.signal }
  );

  /**
   * move blobs to mouse position
   */
  window.addEventListener(
    "mousemove",
    (e) => {
      stage.setPointersPositions(e);
      const pos = stage.getPointerPosition();
      if (!pos) return;

      blobs.forEach(({ tween }, i) => {
        tween.node.to({
          x: pos.x,
          y: pos.y,
          duration: 0.1 + i * 0.1,
          easing: Konva.Easings.Linear,
        });
      });
    },
    { signal: abortController.signal }
  );

  /**
   * trigger colorization animation
   * @see {@link file://./../pages/index.astro}
   */
  animatedTextEls.forEach((el) => {
    el.addEventListener(
      "mouseenter",
      () => {
        blobs.forEach(({ node }, index) => {
          node.setAttrs({
            fillLinearGradientColorStops: getGradientStops(index),
          });
        });
      },
      { signal: abortController.signal }
    );
    el.addEventListener(
      "mouseleave",
      () => {
        blobs.forEach(({ node }) => {
          node.setAttrs({ fillLinearGradientColorStops: [] });
        });
      },
      { signal: abortController.signal }
    );
  });

  window.addEventListener("unload", () => {
    console.log("unload");
    abortController.abort();
  });
</script>
