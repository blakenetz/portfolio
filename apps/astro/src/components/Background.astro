<section id="background" class="fixed inset-0"></section>
<div id="noise"></div>
<style>
  #noise {
    position: fixed;
    inset: -150%;
    width: 400%;
    height: 400%;
    animation: noise-anim 4s steps(8) infinite;
    background: url(/noise.png) repeat;
    background-size: 200px;
    opacity: 0.2;
    pointer-events: none;
  }
  @keyframes noise-anim {
    0% {
      transform: translate(0, 0);
    }
    25% {
      transform: translate(-10%, 5%);
    }
    50% {
      transform: translate(5%, -10%);
    }
    75% {
      transform: translate(-5%, 10%);
    }
    100% {
      transform: translate(0, 0);
    }
  }
</style>

<script>
  import Konva from "konva";

  const cssStyleDeclaration = getComputedStyle(document.documentElement);

  /**
   * @see {@link file://./../styles/global.css} for color variables
   */
  const colors = ["rose", "dodger-blue", "sunglow", "pumpkin", "aquamarine"];

  // Pythagorean theorem to get the diagonal distance of the screen
  const maxWidth = Math.sqrt(
    Math.pow(window.innerWidth, 2) + Math.pow(window.innerHeight, 2)
  );

  function generateRandomPoints(index: number) {
    const length = 8;
    const radius = 100 * Math.pow(1.5, index + 0.25);
    const variance = radius * 0.3;

    return Array.from({ length }, (_, i) => {
      const angle = (i * 2 * Math.PI) / length;
      const r = radius + (Math.random() - 0.5) * variance;
      return [Math.cos(angle) * r, Math.sin(angle) * r];
    }).flat();
  }

  function getGradientStops(index: number) {
    const start = colors[index % colors.length]!;
    const end = colors[(index + 1) % colors.length]!;
    return [
      0,
      cssStyleDeclaration.getPropertyValue(`--color-${start}-500`),
      1,
      cssStyleDeclaration.getPropertyValue(`--color-${end}-500`),
    ];
  }

  /** Create stage and initial layer */
  const stage = new Konva.Stage({
    container: "background",
    width: window.innerWidth,
    height: window.innerHeight,
  });
  const layer = new Konva.Layer();
  const borderLayer = new Konva.Layer();
  stage.add(layer);
  stage.add(borderLayer);

  /**
   * Generate blob nodes until node radius is greater than maxWidth
   */
  const blobNodes: Konva.Line[] = [];
  let isFilled = false;
  const stroke = cssStyleDeclaration.getPropertyValue(
    `--color-papaya-whip-100`
  );
  while (!isFilled) {
    const index = blobNodes.length;

    const x = stage.width() * 0.66;
    const y = stage.height() * 0.33;

    const node = new Konva.Line({
      points: generateRandomPoints(index),
      fillLinearGradientColorStops: [],
      fillLinearGradientStartPoint: { x: x * -1, y: y * -1 },
      fillLinearGradientEndPoint: { x, y },
      stroke,
      strokeWidth: 5,
      closed: true,
      tension: 0.3,
      x,
      y,
    });

    blobNodes.push(node);

    console.log(node.width() / 2, maxWidth);
    if (node.width() / 2 > maxWidth) {
      isFilled = true;
    }
  }

  /**
   * Add blobs to layer and group in reverse order
   * Rotate each blob to randomize gradient direction
   * Create tween for each blob in original order
   */
  const blobs = blobNodes
    .toReversed()
    .map((node) => {
      node.rotation(Math.random() * 360);
      layer.add(node);
      return node;
    })
    .reverse()
    .map((node) => ({ node, tween: new Konva.Tween({ node }) }));

  const animation = new Konva.Animation((frame) => {
    if (!frame) return;
    blobs.forEach(({ node }) => {
      node.skewX(Math.sin(frame.time / 1000) * 0.1);
    });
  });
  animation.start();

  /**
   * Create art-deco checkerboard border
   */
  function createArtDecoBorder() {
    const borderWidth = 100; // Total border width for two squares
    const stroke = cssStyleDeclaration.getPropertyValue(
      `--color-papaya-whip-100`
    );

    // Calculate dimensions that ensure perfect alignment
    const horizontalSegments =
      Math.floor(stage.width() / (borderWidth / 2)) + 1;
    const verticalSegments =
      Math.floor((stage.height() - borderWidth) / (borderWidth / 2)) + 1;

    // Calculate actual square sizes to fit the screen perfectly
    const horizontalSquareSize = stage.width() / horizontalSegments;
    const verticalSquareSize =
      (stage.height() - borderWidth) / verticalSegments;

    // Use the smaller square size to ensure consistency
    const squareSize = Math.min(horizontalSquareSize, verticalSquareSize);

    // Create checkerboard patterns for each edge
    function createCheckerboardStrip(
      startX: number,
      startY: number,
      isHorizontal: boolean
    ) {
      const segments = isHorizontal ? horizontalSegments : verticalSegments;

      for (let i = 0; i < segments; i++) {
        // Create two squares (top/bottom or left/right)
        for (let j = 0; j < 2; j++) {
          // Alternate squares in a checkerboard pattern
          if ((i + j) % 2 === 0) {
            const square = new Konva.Rect({
              x: startX + (isHorizontal ? i * squareSize : j * squareSize),
              y: startY + (isHorizontal ? j * squareSize : i * squareSize),
              width: squareSize,
              height: squareSize,
              fill: stroke,
              stroke: stroke,
              strokeWidth: 1,
            });
            borderLayer.add(square);
          }
        }
      }
    }

    // Top border
    createCheckerboardStrip(0, 0, true);

    // Bottom border
    createCheckerboardStrip(0, stage.height() - squareSize * 2, true);

    // Left border
    createCheckerboardStrip(0, squareSize * 2, false);

    // Right border
    createCheckerboardStrip(
      stage.width() - squareSize * 2,
      squareSize * 2,
      false
    );
  }

  // Call the function to create the border
  createArtDecoBorder();

  /**
   * adjust stage dimensions when window resizes
   */
  window.addEventListener("resize", () => {
    stage.width(window.innerWidth);
    stage.height(window.innerHeight);
    stage.draw();
    borderLayer.destroyChildren();
    createArtDecoBorder();
    borderLayer.draw();
  });

  /**
   * move blobs to mouse position
   */
  window.addEventListener("mousemove", (e) => {
    stage.setPointersPositions(e);
    const pos = stage.getPointerPosition();
    if (!pos) return;

    blobs.forEach(({ tween }, i) => {
      tween.node.to({
        x: pos.x,
        y: pos.y,
        duration: 0.25 + i * 0.1,
        easing: Konva.Easings.Linear,
      });
    });
  });
</script>
