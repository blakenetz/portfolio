<div id="background" class="inset absolute"></div>
<script>
  import Konva from "konva";

  const cssStyleDeclaration = getComputedStyle(document.documentElement);

  /**
   * @see {@link file://./../styles/global.css} for color variables
   */
  const colors = [
    "rose",
    "sunglow",
    "papaya-whip",
    "dodger-blue",
    "pumpkin",
    "aquamarine",
  ];

  /** Helper functions */

  function generateRandomPoints(index: number) {
    const length = 8;
    const radius = 50 * Math.pow(1.5, index + 1);
    const variance = radius * 0.3;

    return Array.from({ length }, (_, i) => {
      const angle = (i * 2 * Math.PI) / length;
      const r = radius + (Math.random() - 0.5) * variance;
      return [Math.cos(angle) * r, Math.sin(angle) * r];
    }).flat();
  }

  function getGradientStops(color: string) {
    return Array.from({ length: 4 }).flatMap((_v, i) => [
      i ? 1 / i : 0,
      cssStyleDeclaration.getPropertyValue(`--color-${color}-${(i + 2) * 100}`),
    ]);
  }

  /** Create stage and initial layer */
  const stage = new Konva.Stage({
    container: "background",
    width: window.innerWidth,
    height: window.innerHeight,
  });
  const layer = new Konva.Layer();
  stage.add(layer);

  /**
   * Generate blobs
   * Rotate each blob
   * Add to layer in reverse order
   * Create tween for each blob in original order
   */
  const blobs = colors
    .map((color, i) => {
      const x = stage.width() * 0.66;
      const y = stage.height() * 0.33;

      return new Konva.Line({
        points: generateRandomPoints(i),
        fillLinearGradientStartPoint: { x: x * -1, y: y * -1 },
        fillLinearGradientEndPoint: { x, y },
        fillLinearGradientColorStops: getGradientStops(color),
        stroke: "black",
        strokeWidth: 5,
        closed: true,
        tension: 0.3,
        x,
        y,
      });
    })
    .reverse()
    .map((node) => {
      node.rotation(Math.random() * 360);
      layer.add(node);
      return node;
    })
    .reverse()
    .map((node, i) => ({
      node,
      tween: new Konva.Tween({
        node,
        duration: 2 + i * 1,
        easing: Konva.Easings.Linear,
      }),
    }));

  /** Event listeners */

  window.addEventListener("resize", () => {
    stage.width(window.innerWidth);
    stage.height(window.innerHeight);
    stage.draw();
  });

  window.addEventListener("mousemove", (e) => {
    stage.setPointersPositions(e);
    const pos = stage.getPointerPosition();
    if (!pos) return;

    blobs.forEach(({ tween }) => {
      tween.pause();
      tween.node.to({
        x: pos.x,
        y: pos.y,
      });
      tween.play();
    });
  });
</script>
